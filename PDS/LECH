./ ADD NAME=$$README 0107-02010-05097-1415-00040-00029-00000-TSO057

      LECHCL is a Language Environment Condition Handler.

      It handles interrupts by printing out errors and allowing the
      program to continue.

      To use LECHCL in a COBOL program, you just code COPY LECHCLD in
      your working-storage section and COPY LECHCLD in your procedure
      division.  Copy/include code is also supplied for C/C++ and for
      LE-enabled assembler.

      Instructions for installation and use are in member LECHDOC of
      this library





      LECHCL is written in COBOL and distributes as COBOL source code.




      Copyright (C) 2000  Andy Robertson

      This program is free software; you can redistribute it and/or
      modify it under the terms of the GNU General Public License as
      published by the Free Software Foundation; either version 2 of the
      License, or (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


./ ADD NAME=LECHALC  0103-02011-02011-1134-00007-00007-00000-TSO057
        CEELOAD  NAME=LECHCLL,FEEDBACK=LECHCL_FC
        ST     15,LECHCL_ROUTINE_POINTER
        CALL CEEHDLR,(LECHCL_ROUTINE_POINTER,LECHCL_TOKEN,LECHCL_FC),VL
        CLC    LECHCL_FC_SEVERITY,=H'0'
        BE     LECHCLCZ
        WTO    ' INITIALISATION OF LECHCL FAILED'
LECHCLCZ DS 0H
./ ADD NAME=LECHALD  0103-02011-02011-1134-00009-00010-00000-TSO057
LECHCL_LOAD_NAME       DC CL8'LECHCLL '
LECHCL_ROUTINE_POINTER DC 2A(0)     PROCEDURE_POINTER
LECHCL_TOKEN           DC A(0)
LECHCL_FC              DC CL12' '
                       ORG LECHCL_FC
LECHCL_FC_SEVERITY     DS H
LECHCL_FC_MSG_NO       DS H
LECHCL_FC_I_S_INFO     DS H
                       ORG
./ ADD NAME=LECHCLC  0105-02010-02010-1335-00014-00013-00000-TSO057

           SET LECHCL-ROUTINE-POINTER TO ENTRY LECHCLL

           CALL 'CEEHDLR' USING LECHCL-ROUTINE-POINTER LECHCL-TOKEN
                                LECHCL-FC

           IF LECHCL-FC-SEVERITY NOT = 0
               MOVE LECHCL-FC-SEVERITY TO
               LECHCL-SEVERITY
               MOVE LECHCL-FC-MSG-NO   TO
               LECHCL-MSG-NO
               DISPLAY LECHCL-SETUP-ERROR UPON CONSOLE
           END-IF

./ ADD NAME=LECHCLD  0105-02010-02010-1440-00014-00012-00000-TSO057
       01  LECHCL-SETUP-ERROR.
           04   FILLER                  PIC X(34)
                VALUE  'INITIALISATION OF LECHCL FAILED '.
           04   LECHCL-SEVERITY         PIC ZZZZ9.
           04   FILLER                  PIC X VALUE ' '.
           04   LECHCL-MSG-NO           PIC ZZZZ9.
       01  LECHCL-ROUTINE-POINTER     PROCEDURE-POINTER.
       01  LECHCLL                    PIC X(8) VALUE 'LECHCLL'.
       01  LECHCL-TOKEN               PIC S9(8) COMP VALUE 0.
       01  LECHCL-FC                  PIC X(12).
       01  FILLER REDEFINES  LECHCL-FC.
           04   LECHCL-FC-SEVERITY      PIC S9(4) COMP.
           04   LECHCL-FC-MSG-NO        PIC S9(4) COMP.
           04   LECHCL-FC-I-S-INFO      PIC S9(8) COMP.
./ ADD NAME=LECHCLL  0156-02010-09167-1620-00960-00732-00000-TSO057


      **************************************************************
      *   LECH LE condition handler for OS/390
      *   Copyright (C) 2000  Andy Robertson
      *
      *   This program is free software; you can redistribute
      *   it and/or modify it under the terms of the GNU
      *   General Public License as published by the Free
      *   Software Foundation; either version 2 of the
      *   License, or (at your option) any later version.
      *
      *   This program is distributed in the hope that it
      *   will be useful, but WITHOUT ANY WARRANTY; without
      *   even the implied warranty of MERCHANTABILITY or
      *   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
      *   General Public License for more details.
      *
      *   You should have received a copy of the GNU General
      *   Public License along with this program; if not,
      *   write to the Free Software Foundation, Inc., 675
      *   Mass Ave, Cambridge, MA 02139, USA.
      *
      **************************************************************











      ******************************************************************
      *                                                                *
      * LECHCLL  IS OUR STANDARD ERROR HANDLER ROUTINE, INVOKED BY THE *
      * CODE IN COPYBOOK "LECHCLC"                                     *
      *                                                                *
      * Andy Robertson  12/01/2002                                     *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************


       IDENTIFICATION DIVISION.
       PROGRAM-ID. 'LECHCLL'.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.



      ******************************************************************
      *                                                                *
      * UTILITY AREAS FOR LE/370 CALLS                                 *
      *                                                                *
      ******************************************************************


       01  FEEDBACK.
           04  FEEDBACK-CONDITION-TOKEN-VALUE.
           COPY  CEEIGZCT.
               07  FEEDBACK-CASE-1-CONDITION-ID.
                   10  FEEDBACK-SEVERITY        PIC S9(4) COMP.
                   10  FEEDBACK-MSG-NO          PIC S9(4) COMP.
               07  FEEDBACK-CASE-2-CONDITION-ID
                         REDEFINES FEEDBACK-CASE-1-CONDITION-ID.
                   10  FEEDBACK-CLASS-CODE      PIC S9(4) COMP.
                   10  FEEDBACK-CAUSE-CODE      PIC S9(4) COMP.
               07  FEEDBACK-CASE-SEV-CTL    PIC X.
               07  FEEDBACK-FACILITY-ID     PIC XXX.
           04  FEEDBACK-I-S-INFO        PIC 9(9) COMP.

       01  FEEDBACK-HEX                  PIC X(24).


       01  MOVE-REPLY                    PIC X.

       01  EDITNUM-X.
           04  EDITNUM                       PIC ZZZZZZZZ9.

       01  CEEMOUT-MSG.
           04  CEEMOUT-MSG-LEN               PIC S9(4) COMP VALUE 80.
           04  CEEMOUT-MSG-TEXT              PIC X(80) VALUE " ".

       01  CEEMOUT-DEST                  PIC S9(9) COMP VALUE 2.

       01  ERROR-WRKCNT            PIC 9(9) COMP VALUE 0.



      ******************************************************************
      *                                                                *
      * DATA AREAS EXTRACT INDEX                                       *
      *                                                                *
      ******************************************************************

       01  DATA-EXTRACT-INDEX.
           04  INT-RESUME-SAME            PIC X.
           04  LOW-CORE                   PIC X.
           04  WILD-BRANCH                PIC X.
           04  SPECIFICATION              PIC X.

      ******************************************************************
      *                                                                *
      * DATA AREAS EXTRACTED BY CALLS TO LE/370 ROUTINES               *
      *                                                                *
      ******************************************************************


           COPY CEEIGZCI.

       01  MSIB.
           04  MSIB-EYECATCHER     PIC X(4).
           04  MSIB-SIZE           PIC S9(4) COMP.
           04  MSIB-LEVEL          PIC S9(4) COMP.
           04  MSIB-GPRS.
               07  MSIB-GPR-X OCCURS 16
                   INDEXED BY MSIB-GPR-IX.
                   10  MSIB-GPR USAGE POINTER.
           04  MSIB-PSW            PIC X(8).
           04  MSIB-PSWX           PIC X(4).
           04  MSIB-IC             PIC X(4).
           04  FILLER              PIC X(8).
           04  MSIB-FPRS.
               07  MSIB-FPR0           PIC X(8).
               07  MSIB-FPR2           PIC X(8).
               07  MSIB-FPR4           PIC X(8).
               07  MSIB-FPR6           PIC X(8).
           04  FILLER REDEFINES MSIB-FPRS.
               07  MSIB-FPR-X OCCURS 4
                   INDEXED BY MSIB-FPR-IX.
                   10  MSIB-FPR.
                   13  MSIB-FPR-1STHALF PIC X(4).
                   13  MSIB-FPR-2NDHALF PIC X(4).

       01  CIB-PTR                 USAGE POINTER.




       01  TRUE-INT-X.
           04  TRUE-INT                USAGE POINTER.
       01  TRUE-RESUME-X.
           04  TRUE-RESUME             USAGE POINTER.
       01  CODE-POINTER-X.
           04  CODE-POINTER-N          PIC 9(8) COMP-5.
           04  CODE-POINTER REDEFINES
               CODE-POINTER-N          USAGE POINTER.


       01  W-DUMP-COUNT         PIC S9(8) COMP.

       01  ten-bytes            PIC X(20).

       01  MODULE-INT           PIC X(8).

       01  MODULE-INT-START USAGE POINTER.
       01  MODULE-INT-START-COMP REDEFINES
           MODULE-INT-START PIC 9(9) COMP.

       01  MODULE-INT-RELA USAGE POINTER.
       01  MODULE-INT-RELA-COMP REDEFINES
           MODULE-INT-RELA PIC 9(9) COMP.




      ******************************************************************
      *                                                                *
      * PRINT WORK AREAS                                               *
      *                                                                *
      ******************************************************************

       01  CEE3DMP-TITLE    PIC X(120).
       01  CEE3DMP-OPTIONS  PIC X(255) value
      *      customise
             'ENCL(CUR),TRACEBACK,VAR'.
      *      'ENCL(CUR),THREAD(CUR),VAR,STORAGE,STACKFRAME(1)'.
      *      customise see CEE3DMP OPTIONS in LE manual Prog Ref

       01  LECHCON          PIC X(255).
       01   W-IDISNAP       PIC X(8)  VALUE 'IDISNAP'.
       01  IDISNAP-TITLE    PIC X(140) VALUE ' ' .

       01  BUFFER-1        PIC X(1500).
       01  WRKCNT          PIC 9(9) COMP.
       01  WRKCNT-2        PIC 9(9) COMP.

       01  display-int-number PIC Z9.

       01  ERROR-TYPE      PIC X(23).

       01  HEX-DATA-4-2    PIC X(8).

      ******************************************************************
      *                                                                *
      * DATA AREAS USED BY NESTED CONDITION HANDLER LECHCLLN           *
      *                                                                *
      ******************************************************************


       01  LECHCLLN-ROUTINE-POINTER   PROCEDURE-POINTER.
       01  LECHCLLN-TOKEN             PIC 9(9) COMP VALUE 0.
       01  CURSOR-MOVE             PIC 9(9) COMP.



      ******************************************************************
      *                                                                *
      * DATA AREAS USED TO KEEP TRACK OF HISTORY OF DUMPS              *
      *                                                                *
      ******************************************************************


       01  UNIQUE-INT-NUMBER            PIC 9(9) COMP VALUE 0.
       01  BIN-INT-NUMBER              PIC 9(9) COMP VALUE 0.
       01  CURR-INT-ADDR-PTR            USAGE POINTER.
       01  CURR-INT-ADDR-COMP
           REDEFINES CURR-INT-ADDR-PTR            PIC 9(9) COMP.

       01  INT-ADDRES                   PIC X(400)  VALUE LOW-VALUES.
       01  FILLER REDEFINES INT-ADDRES.
      *    customise max number of different interrupts tolerated
           04  INT-ADDR OCCURS 100 INDEXED BY
               INT-ADDR-IX.
               07  INT-ADDR-PTR             USAGE POINTER.
               07  INT-ADDR-COMP
                   REDEFINES INT-ADDR-PTR
                   PIC 9(9) COMP.




      *****************************************************************
      *
      * UTILITY AREAS
      *
      *****************************************************************


        01   W-ILC                   PIC 9(4) COMP VALUE 0.


       LINKAGE SECTION.

       01  LINKAGE-tenbyTES              PIC X(10).

       01  LINKAGE-MSIB                  PIC X(100).

       01  LINKAGE-BYTE                PIC X.

           COPY CEEIGZCI REPLACING CEECIB BY LINKAGE-CEECIB.

       01  TOKEN                   PIC 9(9) COMP.

       01  RESULT                  PIC 9(9) COMP.
           88 RESUME                   VALUE 10.
           88 PERCOLATE                VALUE 20.

       01  CURCOND.

           04  CURCOND-CONDITION-TOKEN-VALUE.
           COPY  CEEIGZCT.
               07  CURCOND-CASE-1-CONDITION-ID.
                   10  CURCOND-SEVERITY        PIC S9(4) COMP.
                   10  CURCOND-MSG-NO          PIC S9(4) COMP.
               07  CURCOND-CASE-2-CONDITION-ID
                         REDEFINES CURCOND-CASE-1-CONDITION-ID.
                   10  CURCOND-CLASS-CODE      PIC S9(4) COMP.
                   10  CURCOND-CAUSE-CODE      PIC S9(4) COMP.
               07  CURCOND-CASE-SEV-CTL    PIC X.
               07  CURCOND-FACILITY-ID     PIC XXX.
           04  CURCOND-I-S-INFO        PIC 9(9) COMP.

       01  NEWCOND.

           04  NEWCOND-CONDITION-TOKEN-VALUE.
           COPY  CEEIGZCT.
               07  NEWCOND-CASE-1-CONDITION-ID.
                   10  NEWCOND-SEVERITY        PIC S9(4) COMP.
                   10  NEWCOND-MSG-NO          PIC S9(4) COMP.
               07  NEWCOND-CASE-2-CONDITION-ID
                         REDEFINES NEWCOND-CASE-1-CONDITION-ID.
                   10  NEWCOND-CLASS-CODE      PIC S9(4) COMP.
                   10  NEWCOND-CAUSE-CODE      PIC S9(4) COMP.
               07  NEWCOND-CASE-SEV-CTL    PIC X.
               07  NEWCOND-FACILITY-ID     PIC XXX.
           04  NEWCOND-I-S-INFO        PIC 9(9) COMP.


       PROCEDURE DIVISION USING
           CURCOND, TOKEN, RESULT, NEWCOND.


           PERFORM NEST-HANDLER

           PERFORM FILTER-CONDITIONS

           PERFORM OBTAIN-CIB


           ADD 1 TO BIN-INT-NUMBER

      *    /* print out diagnosis in batch */

      *    to stop producing 1000's of messages, we keep track of
      *    the location of each unique interrupt and only dump
      *    once at each interrupt


           SET CURR-INT-ADDR-PTR TO CIB-INT OF CEECIB
           SET INT-ADDR-IX TO 1
           SEARCH INT-ADDR
           AT END
               ADD 1 TO UNIQUE-INT-NUMBER
           WHEN INT-ADDR-PTR(INT-ADDR-IX) = CURR-INT-ADDR-PTR
               PERFORM DUMMY-PARA
           WHEN INT-ADDR-COMP(INT-ADDR-IX) = 0
               SET INT-ADDR-PTR(INT-ADDR-IX)
               TO CURR-INT-ADDR-PTR
               ADD 1 TO UNIQUE-INT-NUMBER
               MOVE UNIQUE-INT-NUMBER TO display-int-number
               PERFORM SET-TITLE
               MOVE CEE3DMP-TITLE TO LECHCON
               PERFORM SEND-MSG-LECHCON
               MOVE '                                      ****'
                                  TO LECHCON
               PERFORM SEND-MSG-LECHCON
               MOVE '                                          '
                                  TO LECHCON
               PERFORM SEND-MSG-LECHCON

      *    customise max number of LE dumps issued in a step
               IF UNIQUE-INT-NUMBER < 11
                   PERFORM CALL-DUMPER
               END-IF
      *    customise max number of different interrupts tolerated
               IF UNIQUE-INT-NUMBER > 99
                   CALL "LECHCON" USING BY CONTENT '   $'
                   CALL "LECHCON" USING BY CONTENT
          "C LECHCL MAX UNIQUE INTERRUPTS EXCEEDED - JOB ENDS$"
               END-IF
           END-SEARCH
           PERFORM POPUP-OR-RESUME

      *    You should never get here

           CALL "LECHCON" USING BY CONTENT '   $'
           CALL 'LECHCON' USING BY CONTENT
           'C LECHCL - run on past popup$'
           STOP RUN




           .

       FILTER-CONDITIONS.
      *    DISPLAY "FILTER-CONDITIONS"  DATA-EXTRACT-INDEX
      *    DISPLAY "CURCOND=(" CURCOND ")"

      *
      *    GOBACK WITH PERCOLATE UNLESS CONDITION IS ONE WE ARE
      *    PREPARED TO HANDLE
      *

           MOVE "N" TO SPECIFICATION

           EVALUATE TRUE
           WHEN CEE341 OF CURCOND
               MOVE "Operation" TO ERROR-TYPE
           WHEN CEE342 OF CURCOND
               MOVE "Priviliged_operation" TO ERROR-TYPE
           WHEN CEE343 OF CURCOND
               MOVE "Execute            " TO ERROR-TYPE
           WHEN CEE344 OF CURCOND
               MOVE "Protection            " TO ERROR-TYPE
           WHEN CEE345 OF CURCOND
               MOVE "Addressing               " TO ERROR-TYPE
           WHEN CEE346 OF CURCOND
               MOVE "Specification            " TO ERROR-TYPE
               MOVE 'Y' TO SPECIFICATION
           WHEN CEE347 OF CURCOND
               MOVE "Decimal_Data    " TO ERROR-TYPE
           WHEN CEE348 OF CURCOND
               MOVE "Fixed_point_overflow            " TO ERROR-TYPE
           WHEN CEE349 OF CURCOND
               MOVE "Fixed_point_divide            " TO ERROR-TYPE
           WHEN CEE34A OF CURCOND
               MOVE "Decimal_overflow            " TO ERROR-TYPE
           WHEN CEE34B OF CURCOND
               MOVE "Decimal_divide            " TO ERROR-TYPE
           WHEN CEE34C OF CURCOND
               MOVE "Exponent_overflow            " TO ERROR-TYPE
           WHEN CEE34D OF CURCOND
               MOVE "Exponent_underflow            " TO ERROR-TYPE
           WHEN CEE34E OF CURCOND
               MOVE "Significance            " TO ERROR-TYPE
           WHEN CEE34F OF CURCOND
               MOVE "Floating_point_divide            " TO ERROR-TYPE
           WHEN OTHER
               SET PERCOLATE TO TRUE
               GOBACK
           END-EVALUATE
           .

       OBTAIN-CIB.
      *    display "OBTAIN-CIB"         data-extract-index



           MOVE ALL "?" TO CEECIB
           CALL "CEE3CIB" USING CURCOND CIB-PTR FEEDBACK
           IF NOT CEE000 OF FEEDBACK
               PERFORM SEND-MSG-TEXT
               STRING "LECHCLL: Bad feedback calling CEE3CIB "
               DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
               PERFORM SEND-MSG-TEXT
               PERFORM SEND-MSG-FEEDBACK
               PERFORM SEND-MSG-TEXT
           ELSE
               SET ADDRESS OF LINKAGE-CEECIB TO CIB-PTR
               MOVE LINKAGE-CEECIB TO CEECIB
               SET TRUE-INT TO CIB-INT OF CEECIB
               SET TRUE-RESUME TO CIB-RSM-POINT OF CEECIB
               IF TRUE-RESUME = TRUE-INT
                   MOVE "Y" TO INT-RESUME-SAME
               END-IF
      *
      *    IF THE RESUME POINTER IS AT LESS THAN 4096 WE ARE IN LOW CORE
      *
               MOVE "N" TO LOW-CORE
               MOVE 0 TO WRKCNT
               CALL "LECHCLL4" USING TRUE-INT WRKCNT WRKCNT-2
               IF WRKCNT-2 < 4096
                   MOVE "Y" TO LOW-CORE
               ELSE
      *
      *    SET INST LEN
      *
                   CALL "LECHCLL4" USING TRUE-RESUME TRUE-INT WRKCNT-2

                   MOVE ALL '?' TO MODULE-INT

               END-IF

           END-IF

           .

       SEt-TITLE.
      *    display "SEND-MSG-LECHCON"

      *    1)  GET HEADER STRING

           MOVE " " TO CEE3DMP-TITLE

           SET CODE-POINTER TO TRUE-INT
           SUBTRACT 4 FROM CODE-POINTER-N
           SET ADDRESS OF LINKAGE-tenbyTES TO CODE-POINTER
           MOVE ALL '?' TO ten-bytes
           CALL "LECHCVX" USING
           LINKAGE-tenbyTES
           ten-bytes
           BY CONTENT LENGTH OF
           LINKAGE-tenbyTES

           CALL "LECHCVX" USING
           CIB-INT OF CEECIB
           HEX-DATA-4-2
           BY CONTENT LENGTH OF
           CIB-INT OF CEECIB

           STRING
           "  INTERRUPT " DELIMITED SIZE
           display-int-number
           " AT " DELIMITED SIZE
           HEX-DATA-4-2 DELIMITED SIZE
           " - " DELIMITED SIZE
           "'"   DELIMITED SIZE
           ten-bytes DELIMITED SIZE
           "' "   DELIMITED SIZE
           ERROR-TYPE DELIMITED SIZE
           " " DELIMITED SIZE
           INTO CEE3DMP-TITLE

           .


       SEND-MSG-LECHCON.
      *    display "SEND-MSG-LECHCON"


           INSPECT  LECHCON CONVERTING "_" TO " "
           CALL "LECHCON" USING LECHCON

           .

       CALL-DUMPER.
      *    DISPLAY "CALL-DUMPER"
      *    customise max number of dumps issued
           IF W-DUMP-COUNT < 10
               MOVE CEE3DMP-TITLE TO IDISNAP-TITLE(1:40)
               CALL W-IDISNAP USING BY CONTENT '0001'
                                    BY REFERENCE IDISNAP-TITLE
               ON EXCEPTION
                   PERFORM DUMMY-PARA
                   CALL "CEE3DMP" USING CEE3DMP-TITLE CEE3DMP-OPTIONS
                   FEEDBACK
                   END-CALL
               END-CALL
               ADD 1 TO W-DUMP-COUNT
           END-IF


           .

       SEND-MSG-FEEDBACK.
      *    DISPLAY "SEND-MSG-FEEDBACK"

           PERFORM SEND-MSG-TEXT

           MOVE FEEDBACK-SEVERITY TO EDITNUM
           STRING "                  Severity = " EDITNUM
           DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
           PERFORM SEND-MSG-TEXT
           MOVE FEEDBACK-MSG-NO TO EDITNUM
           STRING "                  Msg-No   = " EDITNUM
           DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
           PERFORM SEND-MSG-TEXT
           MOVE FEEDBACK-CASE-SEV-CTL TO EDITNUM
           STRING "                  Sev-Ctl  = " EDITNUM
           DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
           PERFORM SEND-MSG-TEXT
           MOVE FEEDBACK-FACILITY-ID TO EDITNUM
           STRING "                  Facility = " EDITNUM
           DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
           PERFORM SEND-MSG-TEXT
           MOVE FEEDBACK-I-S-INFO TO EDITNUM
           STRING "                  I-S-Info = " EDITNUM
           DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
           PERFORM SEND-MSG-TEXT
           .



       SEND-MSG-TEXT.
      *    display "SEND-MSG-TEXT"
      *    CEEMOUT-MSG-TEXT

           CALL "CEEMOUT" USING CEEMOUT-MSG CEEMOUT-DEST FEEDBACK
           MOVE " " TO CEEMOUT-MSG-TEXT
           .

           .
       NEST-HANDLER.
      *    display "NEST-HANDLER"

           SET LECHCLLN-ROUTINE-POINTER TO ENTRY "LECHCLLN"

           CALL "CEEHDLR" USING LECHCLLN-ROUTINE-POINTER LECHCLLN-TOKEN
                                FEEDBACK

           IF FEEDBACK-SEVERITY NOT = 0
               STRING "LECHCLL ERROR CALLING CEEHDLR"
               DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
               PERFORM SEND-MSG-TEXT

               PERFORM SEND-MSG-FEEDBACK
           END-IF

           .

       POPUP-OR-RESUME.
      *    display "POPUP-OR-RESUME"

      *
      *
      *    CONDITIONS WHICH REQUIRE POP ONE LEVEL UP
      *
      *
           IF LOW-CORE = "Y"
               CALL "LECHCON"   USING BY CONTENT '  $'
               CALL "LECHCON"   USING BY CONTENT
               "C LECHCL LOW CORE - JOB ABENDED$"
               STOP RUN
           END-IF
      *
      *    display "POPUP " data-extract-index
      *
           IF INT-RESUME-SAME = "Y"
           OR WILD-BRANCH = "Y"

      *    display "POPUP -popped"
               MOVE 0 TO CURSOR-MOVE
               CALL "CEEMRCR" USING CURSOR-MOVE FEEDBACK
               IF FEEDBACK-SEVERITY NOT = 0
                   ADD 1 TO ERROR-WRKCNT
                   IF ERROR-WRKCNT > 1000
                       CALL "LECHCON"   USING BY CONTENT '  $'
                       CALL "LECHCON" USING BY CONTENT
                       "C LECHCLL EXCESSIVE NUMBER OF INTERNAL ERRORS$"
                   END-IF
                   STRING "          LECHCLL error calling CEEMRCR"
                   DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
                   PERFORM SEND-MSG-TEXT
                   PERFORM SEND-MSG-FEEDBACK
               END-IF

               PERFORM UNNEST-AND-RESUME
           END-IF
      *

           PERFORM UNNEST-AND-RESUME
           .

       DUMMY-PARA.
      *    display "DUMMY-PARA"
           EXIT

           .

       UNNEST-AND-RESUME.
      *    display "UNNEST-AND-RESUME"

      *    REMOVE HANDLER LECHCLN

           CALL "CEEHDLU" USING LECHCLLN-ROUTINE-POINTER
                                FEEDBACK
           IF FEEDBACK-SEVERITY NOT = 0
               ADD 1 TO ERROR-WRKCNT
               IF ERROR-WRKCNT > 1000
                   CALL "LECHCON"   USING BY CONTENT '  $'
                   CALL "LECHCON" USING BY CONTENT
                   "C LECHCLL EXCESSIVE NUMBER OF INTERNAL ERRORS$"
               END-IF
               STRING "LECHCLL ERROR CALLING CEEHDLU"
               DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
               PERFORM SEND-MSG-TEXT
               PERFORM SEND-MSG-FEEDBACK
           END-IF
           SET RESUME TO TRUE
           GOBACK
           .


       END PROGRAM 'LECHCLL'.



      ******************************************************************
      *      LECHCLL4 - GIVEN TWO ADDRESSES, RETURN DIFFERENCE         *
      *                 GIVEN ADDRESSES HAVE BIT 0 TRIMMED OFF         *
      *                 ALWAYS.                                        *
      *                                                                *
      *                 NOTE WE CANNOT SIMPLY SUBTRACT PIC S9(8) COMP  *
      *                 FIELDS BECAUSE OF THE WAY COBOL TREATS THEM    *
      *                                                                *
      *                 REQUIRES TRUNC(OPT)                            *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. 'LECHCLL4'.
       DATA DIVISION.

       WORKING-STORAGE SECTION.

       01  W-NUM-1           PIC S9(18) COMP.
       01  W-NUM-1-X REDEFINES W-NUM-1  PIC X(8).
       01  W-NUM-2           PIC S9(18) COMP.
       01  W-NUM-2-X REDEFINES W-NUM-2  PIC X(8).

       LINKAGE SECTION.

       01  FIRST-ADDR       PIC XXXX.
       01  SECOND-ADDR      PIC XXXX.
       01  DIFF             PIC XXXX.

       PROCEDURE DIVISION USING FIRST-ADDR SECOND-ADDR DIFF.

           MOVE 0 TO W-NUM-1
           MOVE 0 TO W-NUM-2

           MOVE FIRST-ADDR TO W-NUM-1-X(5:)
           IF W-NUM-1 > (2 ** 31)
               COMPUTE W-NUM-1 = W-NUM-1 - (2 ** 31)
           END-IF

           MOVE SECOND-ADDR TO W-NUM-2-X(5:)
           IF W-NUM-2 > (2 ** 31)
               COMPUTE W-NUM-2 = W-NUM-2 - (2 ** 31)
           END-IF

           COMPUTE W-NUM-2 = W-NUM-1 - W-NUM-2

           MOVE W-NUM-2-X(5:) TO DIFF

           GOBACK.

       END PROGRAM 'LECHCLL4'.



      ******************************************************************
      *                                                                *
      * LECHCLLN IS A NESTED ERROR HANDLER WHICH SIMPLY GOES BACK      *
      *                                                                *
      * IT IS SET UP AT THE START OF LECHCLL  AND CANCELLED AT THE     *
      * END OF LECHCLL                                                 *
      *                                                                *
      * THE POINT IS MERELY TO INTERCEPT ANY ERRORS IN LECHCLDA. IT    *
      * DOES NOT FLAG THESE ERRORS - THEY MUST BE DETECTED BY LECHCLDA *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. 'LECHCLLN'.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       01  FEEDBACK.
           04  FEEDBACK-CONDITION-TOKEN-VALUE.
               07  FEEDBACK-CASE-1-CONDITION-ID.
                   10  FEEDBACK-SEVERITY        PIC S9(4) COMP.
                   10  FEEDBACK-MSG-NO          PIC S9(4) COMP.
               07  FEEDBACK-CASE-2-CONDITION-ID
                         REDEFINES FEEDBACK-CASE-1-CONDITION-ID.
                   10  FEEDBACK-CLASS-CODE      PIC S9(4) COMP.
                   10  FEEDBACK-CAUSE-CODE      PIC S9(4) COMP.
               07  FEEDBACK-CASE-SEV-CTL    PIC X.
               07  FEEDBACK-FACILITY-ID     PIC XXX.
           04  FEEDBACK-I-S-INFO        PIC 9(9) COMP.

       01  ERROR-WRKCNT            PIC 9(9) COMP VALUE 0.
       01  CEEMOUT-MSG.
           04  CEEMOUT-MSG-LEN               PIC S9(4) COMP VALUE 80.
           04  CEEMOUT-MSG-TEXT              PIC X(80).

       01  CEEMOUT-DEST                  PIC S9(9) COMP VALUE 2.

       01  EDITNUM                       PIC ZZZZZZZZ9.

       LINKAGE SECTION.


       01  TOKEN                   PIC 9(9) COMP.

       01  RESULT                  PIC 9(9) COMP.
           88 RESUME                   VALUE 10.

       01  CURCOND.

           04  CURCOND-CONDITION-TOKEN-VALUE.
           COPY  CEEIGZCT.
               07  CURCOND-CASE-1-CONDITION-ID.
                   10  CURCOND-SEVERITY        PIC S9(4) COMP.
                   10  CURCOND-MSG-NO          PIC S9(4) COMP.
               07  CURCOND-CASE-2-CONDITION-ID
                         REDEFINES CURCOND-CASE-1-CONDITION-ID.
                   10  CURCOND-CLASS-CODE      PIC S9(4) COMP.
                   10  CURCOND-CAUSE-CODE      PIC S9(4) COMP.
               07  CURCOND-CASE-SEV-CTL    PIC X.
               07  CURCOND-FACILITY-ID     PIC XXX.
           04  CURCOND-I-S-INFO        PIC 9(9) COMP.

       01  NEWCOND.

           04  NEWCOND-CONDITION-TOKEN-VALUE.
           COPY  CEEIGZCT.
               07  NEWCOND-CASE-1-CONDITION-ID.
                   10  NEWCOND-SEVERITY        PIC S9(4) COMP.
                   10  NEWCOND-MSG-NO          PIC S9(4) COMP.
               07  NEWCOND-CASE-2-CONDITION-ID
                         REDEFINES NEWCOND-CASE-1-CONDITION-ID.
                   10  NEWCOND-CLASS-CODE      PIC S9(4) COMP.
                   10  NEWCOND-CAUSE-CODE      PIC S9(4) COMP.
               07  NEWCOND-CASE-SEV-CTL    PIC X.
               07  NEWCOND-FACILITY-ID     PIC XXX.
           04  NEWCOND-I-S-INFO        PIC 9(9) COMP.


       PROCEDURE DIVISION USING
           CURCOND, TOKEN, RESULT, NEWCOND.

      *    DISPLAY 'LECHCLLN ENTERED'

           ADD 1 TO ERROR-WRKCNT
           IF ERROR-WRKCNT > 1000
               CALL 'LECHCON' USING BY CONTENT '  $'
               CALL 'LECHCON' USING BY CONTENT
               'C LECHCLDA EXCESSIVE NUMBER OF INTERNAL ERRORS$'
           END-IF
           SET RESUME TO TRUE
      *    DISPLAY 'LECHCLLN norm ret'
           GOBACK
           .


       END PROGRAM 'LECHCLLN'.

















       IDENTIFICATION DIVISION.

       PROGRAM-ID.                    LECHCON.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       01  W-COUNT                   PIC S9(8) COMP.

       01  W-DUMMY                   PIC X(200) VALUE ' '.
       01  W-STARS                   PIC X(70) VALUE ALL ' '.
       01  W-DISPLAY.
           04  W-DISPLAY-START       PIC X VALUE  '*'.
           04  W-DISPLAY-MID         PIC X(70) VALUE ALL ' '.
       01  W-LAST-MSG-CHAR           PIC X     VALUE     ' '.
       01  W-LASTLINE.
           04  W-LASTLINE-START PIC X(27) VALUE ALL '*'.
           04  W-LASTLINE-MID   PIC X(16) VALUE
           ' LECHCON CLASS '.
           04  W-LASTLINE-TYPE  PIC X VALUE     '?'.
           04  FILLER           PIC X VALUE     ' '.
           04  W-LASTLINE-END   PIC X(25) VALUE ALL '*'.

       LINKAGE SECTION.

       01  CON-MSG                   PIC X(82).

       01  CON-REPLY                 PIC X(82).

       01  CON-REPLY-LEN             PIC S9(8) COMP.


       PROCEDURE DIVISION USING CON-MSG CON-REPLY CON-REPLY-LEN.

           MOVE 1 TO W-COUNT
           PERFORM VARYING W-COUNT FROM 1 BY 1
           UNTIL W-COUNT = LENGTH OF CON-MSG
           OR CON-MSG(W-COUNT:1) = '$'
           END-PERFORM

           SUBTRACT 2 FROM W-COUNT

           IF W-COUNT < 1
               MOVE 1 TO W-COUNT
           END-IF


           MOVE CON-MSG(2:W-COUNT) TO W-DISPLAY-MID

           DISPLAY W-DISPLAY UPON CONSOLE

           IF CON-MSG(1:1) = 'C'

               MOVE 2000 TO RETURN-CODE
               STOP RUN

           END-IF

           MOVE 0 TO RETURN-CODE

           GOBACK.
       END PROGRAM LECHCON.

       IDENTIFICATION DIVISION.

       PROGRAM-ID.     LECHCVX.

      * MODULE TO CONVERT CHARS TO HEX
      *
      * MODIFICATION HISTORY:
      *

       ENVIRONMENT DIVISION.

       DATA DIVISION.
       WORKING-STORAGE SECTION.


       01  CHARS-POINTER       PIC S9(8) COMP.

       01  HEX-POINTER         PIC S9(8) COMP.

       01  TAB-INDX.
       04  TAB-IND             PIC S9(8) COMP.

       01  TAB.
        04 T0 PIC X(32) VALUE  '000102030405060708090A0B0C0D0E0F'.
        04 T1 PIC X(32) VALUE  '101112131415161718191A1B1C1D1E1F'.
        04 T2 PIC X(32) VALUE  '202122232425262728292A2B2C2D2E2F'.
        04 T3 PIC X(32) VALUE  '303132333435363738393A3B3C3D3E3F'.
        04 T4 PIC X(32) VALUE  '404142434445464748494A4B4C4D4E4F'.
        04 T5 PIC X(32) VALUE  '505152535455565758595A5B5C5D5E5F'.
        04 T6 PIC X(32) VALUE  '606162636465666768696A6B6C6D6E6F'.
        04 T7 PIC X(32) VALUE  '707172737475767778797A7B7C7D7E7F'.
        04 T8 PIC X(32) VALUE  '808182838485868788898A8B8C8D8E8F'.
        04 T9 PIC X(32) VALUE  '909192939495969798999A9B9C9D9E9F'.
        04 TA PIC X(32) VALUE  'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'.
        04 TB PIC X(32) VALUE  'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'.
        04 TC PIC X(32) VALUE  'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'.
        04 TD PIC X(32) VALUE  'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'.
        04 TE PIC X(32) VALUE  'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'.
        04 TF PIC X(32) VALUE  'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'.




       LINKAGE SECTION.

       01  CHARS               PIC X(100000).

       01  HEX                 PIC X(200000).

       01  LEN                 PIC S9(8) COMP.


       PROCEDURE DIVISION USING CHARS HEX LEN.


           MOVE 'N' TO HEX(1:1)

           IF LEN NOT > 0 GOBACK END-IF

           MOVE 1 TO CHARS-POINTER
           MOVE 1 TO  HEX-POINTER

           PERFORM UNTIL CHARS-POINTER > LEN


               MOVE 0 TO TAB-IND
               MOVE CHARS(CHARS-POINTER:1) TO TAB-INDX(4:1)
               COMPUTE TAB-IND = (TAB-IND * 2) + 1
               MOVE TAB(TAB-IND:2) TO HEX(HEX-POINTER:2)
               ADD 1 TO CHARS-POINTER
               ADD 2 TO  HEX-POINTER


           END-PERFORM

           GOBACK.
./ ADD NAME=LECHDOC  0117-02010-09167-1616-00190-01389-00000-TSO057
                                                           Ver 1.1
                                                            8 Apr 2005


  FUNCTION - GENERAL DESCRIPTION
  ------------------------------


  1.  LECH is a Language Environment CONDITION HANDLER.

      It will intercept conditions that would make a program abend and
      allow the program to continue

      It will print out a message and a dump when an interrupt occurs
      and then return to the interrupted program at the next machine
      instruction so the program can continue



      The conditions handled are the classic ones:

                     Operation
                     Priviliged_operation
                     Execute
                     Protection
                     Addressing
                     Specification
                     Decimal_Data
                     Fixed_point_overflow
                     Fixed_point_divide
                     Decimal_overflow
                     Decimal_divide
                     Exponent_overflow
                     Exponent_underflow
                     Significance
                     Floating_point_divide


      LECH will put out a message and a dump the first time a condition
      occurs at any particular address.  Control is then returned to the
      abending program, and it may continue to run.

      If a condition recurs later at the same address no action will be
      taken.

      Up to 100 different unique conditions can be intercepted (this
      limit is customisable).   After that the program is allowed to
      abend.

      The message has form eg


       INTERRUPT  1 AT 24701132 - '2008A17DFA402008A040' Decimal Data
                                           ****
                                           |
                                       interrupt here


      As an aid to debugging 4 bytes before and 6 bytes after the
      interrupt are displayed in hex.


      LECH then attempts to invoke IDISNAP (Fault Analyzer) to print
      off a proper analysis.  If IDISNAP is not available, LECH will
      call CEE3DMP instead.




  2.  To use LECH, code


            COPY LECHCLD.


          in your WORKING-STORAGE, and


            COPY LECHCLC.


          at the start of your PROCEDURE DIVISION.


      Then compile your programs with the LECH COBOL library in the
      SYSLIB concatenation.


      You only need to include these copybooks in your mainline, not any
      subprograms


  3.  Copybooks LECHALC and LECHALD are supplied for use from
      LE-compliant assembler.

  4.  Headers LECHELC and LECHELD are supplied for use from C/C++



  HOW TO INSTALL LECH
  -------------------


 10.  Prerequisites:

      o  OS/390, any level

      o  Language Environment, any level.

      o  COBOL II or later



 11.  To install LECH

      o  The LECH COBOL library is in zipped TSO XMIT format. It is
         available from:

              http://home.clara.net/andywrobertson/mvsindex.html

         Follow the instructions at that site to download it, unzip it,
         SEND it to your mainframe as a flat file and TSO RECEIVE it
         into a library.

      o  Examine member LECHDOC (this member) for any updates

      o  Perform any customisations on the source of LECHCLL.
         Sections where customisation is recommended are commented
         (search for the string "customise")

      o  Customise and run the job LECHINST. This will put LECHCLL
         in a load library, which you must create beforehand.  This
         library must be linklisted or steplibed to your live jobs

      o  You may run LECHIVP1 to demonstrate LECH handling interrupts
         in COBOL

      o  You may run LECHIVP2 to demonstrate LECH handling interrupts
         in LE COMPLIANT ASSSEMBLER

      o  You may run LECHIVP3 to demonstrate LECH handling interrupts
         in C/C++

      o  Note you must run with TRAP(ON).  I assume this is a universal
         default.




  SAMPLE ROUTINE LECHMOVE
  -----------------------


 20.  This has nothing to do with LECH but it is supplied in case you
      may find it useful. The idea is a callable subroutine which
      will move data between two locations if the locations are
      accessible, but will return a flag rather than abend if the
      data cannot be accessed or if the to-field is protected.



           CALL 'LECHMOVE' USING FROM-FIELD
                                 TO-FIELD
                                 MOVE-LENGTH
                                 REPLY-FLAG

      REPLY-FLAG is set to 'V' if the move is successful, 'N' if not.




  SAMPLE ROUTINE LECHNL
  ---------------------


 30.  This is a NON-LE routine that can be called from non-LE programs.
      It sets an ESTAE and traps abends, restarting the abending
      program with a message.

      To use it code:


           CALL 'LECHNL'

      at the beginning of your program


      It needs the INSTASM routines available from
           http://home.clara.net/andywrobertson/mvsindex.html

./ ADD NAME=LECHELC  0112-02011-02011-1230-00013-00013-00000-TSO057

     lechcl_routine_pointer.address
     = (lechcl_funcV *) fetch("LECHCLL");
     lechcl_routine_pointer.nesting = NULL;

     CEEHDLR(&lechcl_routine_pointer,&lechcl_token,&lechcl_fc);

     if (_FBCHECK (lechcl_fc, CEE000) != 0)
         ??<
         printf("INITIALISATION OF LECHCLL FAILED");
         return;
         ??>;

./ ADD NAME=LECHELD  0109-02011-02011-1230-00011-00013-00000-TSO057
       #include <leawi.h>
       #include <ceeedcct.h>


       _ENTRY lechcl_routine_pointer;
       _INT4  lechcl_token;
       _FEEDBACK lechcl_fc;

        typedef void lechcl_funcV();
        #pragma linkage(lechcl_funcV, COBOL)

./ ADD NAME=LECHINST 0109-02010-09166-1651-00080-00044-00000-TSO057
//TSO057X JOB (T951V57),                                                JOB09309
//           CLASS=A,MSGCLASS=T,REGION=300M,
//           NOTIFY=TSO057
// INCLUDE MEMBER=SYSLEV
//*
//*
//******************************************************************
//*                                                                *
//*  THIS JOB WILL COMPILE AND LINK LECHCLL INTO A                 *
//*  LOAD LIBRARY, WHICH YOU MUST PRE-ALLOCATE BEFORE RUNNING      *
//*                                                                *
//*  THIS LIBRARY MUST BE LINKLISTED OR STEPLIBED TO ANY PROGRAM   *
//*  THAT USES LECHCLL                                             *
//*                                                                *
//******************************************************************
//*
//******************************************************************
//* HISTORY                                                        *
//******************************************************************
//*                                                                *
//* 12 JAN 2002 1.0  WRITTEN                                  AWR  *
//*                                                                *
//******************************************************************
//*
//*      TO RUN THIS JOB
//*      ---------------
//*
//*  1) CHANGE THE JOBCARD
//*
//*
//*  2) CHANGE THE NAMES OF:
//*
//*        PP.LECH.COBOL - TO THE LECHCLL COBOL LIBRARY
//*
//*        JLP.TEST.LOADLIB  - TO THE LOAD LIBRARY WHERE YOU WANT
//*                            LECHCLL TO BE STORED
//*
//*        SYS1. LIBRARIES    - AS APPROPRIATE
//*
//*  1) CHANGE THE JOBCARD
//*
//*
//*
//* COBOL COMPILE - NB COMPILE OPTIONS NOSSRANGE,RENT
//*
//C        EXEC PGM=IGYCRCTL,COND=(4,LT),REGION=7M,
// PARM=('NOOFFSET,NOSSRANGE,RENT,LIST',
//       'NODYNAM,LIB,APOST,NOCICS,TRUNC(OPT)')
//STEPLIB  DD   DISP=SHR,DSN=SYSPP.COBOS410.SIGYCOMP
//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSUT2   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSUT3   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSUT4   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSUT5   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSUT6   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSUT7   DD   UNIT=SYSALLDA,SPACE=(6233,(150,300),,,ROUND)
//SYSLIN   DD   DSN=&&OBJ,DISP=(NEW,PASS),BLKSIZE=3120,
//         UNIT=SYSALLDA,SPACE=(80,(1500,7750))
//SYSPRINT DD   SYSOUT=*
//SYSLIB  DD   DISP=SHR,DSN=PP.LECH.COBOL                  <== CHANGE
//         DD   DSN=SYS1.&SYSMINL..ACEESRC1,DISP=SHR       <== CHANGE
//SYSIN    DD   DSN=PP.LECH.COBOL(LECHCLL),DISP=SHR        <== CHANGE
//*
//*
//* LINKEDIT
//*
//*
//* STANDARD LINKEDIT PROC
//*
//LINK     EXEC PGM=HEWL,COND=(4,LT),
// PARM=('XREF,LIST,MAP',
// 'AMODE=31,RMODE=ANY,RENT,REUS')
//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1024,(100,30))
//SYSPRINT DD   SYSOUT=*
//SYSLMOD  DD   DSN=JLP.TEST.LOADLIB(LECHCLL),DISP=SHR     <== CHANGE
//SYSLIB   DD UNIT=SYSALLDA,SPACE=(1,(1,1,1)),BLKSIZE=32760,RECFM=U
//         DD   DSN=SYS1.&SYSMINL..SCEELKED,DISP=SHR       <== CHANGE
//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)
//         DD   *
//*
./ ADD NAME=LECHIVPA 0199-99026-05108-0945-00053-00007-00000-TSO057
*
*
* THIS IS A SAMPLE LE COMPLIANT ASSEMBLER PROGRAM USING LECH
*
*




* LE COMPLIANT ENTRY
LECHIVPA CEEENTRY MAIN=YES,PPA=LECHIVPARMPPA,BASE=11,PLIST=MVS
*

         USING LECHIVPA,11


*
* COPYBOOK 1
*
         COPY LECHALC


*
* MAKE THE ABEND
*
         LA   1,0
         LA   2,0
         LA   3,0
         LA   4,0
         DR   2,1


         L    4,=A(X'00FFFF00')
         BR   4

* LE COMPLIANT TERMINATION
         CEETERM RC=0
         LTORG
LECHIVPARMPPA CEEPPA
         CEEDSA
         CEECAA






LECHIVPA CSECT

*
* COPYBOOK 2
*
         COPY LECHALD
./ ADD NAME=LECHIVPC 0102-02011-03021-1045-00040-00040-00000-TSO057
       IDENTIFICATION DIVISION.

       PROGRAM-ID.        'LECHIVPC'.

       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE  SECTION.

       01  ADDR-X.
           04  ADDR   PIC S9(8) COMP VALUE 0.

       01  AAA-X.
           04   AAA   PIC S9(8) COMP-3.


       01  W-0  PIC S9(8) COMP VALUE 0.
       01  W-1  PIC S9(8) COMP VALUE 1.
       01  W-2  PIC S9(8) COMP VALUE 2.

           COPY LECHCLD.


       PROCEDURE DIVISION.


           COPY LECHCLC.



           PERFORM 3 TIMES
               MOVE ' ' TO AAA-X
               ADD 1 TO AAA
               DIVIDE W-1 BY W-0 GIVING W-2
           END-PERFORM


           GOBACK.

       END PROGRAM 'LECHIVPC'.

./ ADD NAME=LECHIVPE 0133-99302-02011-1233-00017-00041-00000-TSO057
  /*          sample c/c++ use of LECH */

  ??=include "LECHELD.h"

  main ()
    ??<
      int i = 0;
      int j = 0;
      int k = 0;

      ??=include "LECHELC.h"

      i = j / k;

      return;

  ??>
./ ADD NAME=LECHIVP1 0105-02011-09166-1651-00078-00077-00000-TSO057
//TSO057X JOB (T951V57),
//           CLASS=A,MSGCLASS=T,REGION=300M,
//           NOTIFY=TSO057
// INCLUDE MEMBER=SYSLEV
//*
//*
//*
//******************************************************************
//*                                                                *
//*  THIS JOB WILL COMPILE AND LINK LECHIVPC, AND RUN IT           *
//*                                                                *
//******************************************************************
//*
//******************************************************************
//* HISTORY                                                        *
//******************************************************************
//*                                                                *
//* 12 JAN 2002 1.0  WRITTEN                                  AWR  *
//*                                                                *
//******************************************************************
//*
//*      TO RUN THIS JOB
//*      ---------------
//*
//*  1) CHANGE THE JOBCARD
//*
//*
//*  2) CHANGE THE NAMES OF:
//*
//*        PP.LECH.COBOL - TO THE LECHCLL COBOL LIBRARY
//*
//*        JLP.TEST.LOADLIB  - TO THE LOAD LIBRARY WHERE YOU WANT
//*                            LECHCLL TO BE STORED
//*
//*
//*
//*
//C        EXEC PGM=IGYCRCTL,COND=(4,LT),REGION=7M,
// PARM=('NOOFFSET,NOSSRANGE,RENT,LIST',
//       'NODYNAM,LIB,APOST,NOCICS')
//STEPLIB  DD   DISP=SHR,DSN=SYSPP.COBOS410.SIGYCOMP
//SYSUT1   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSUT2   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSUT3   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSUT4   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSUT5   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSUT6   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSUT7   DD   UNIT=VIO,SPACE=(6233,(150,300),,,ROUND)
//SYSLIN   DD   DSN=&&OBJ,DISP=(NEW,PASS),BLKSIZE=3120,
//         UNIT=VIO,SPACE=(80,(1500,7750))
//SYSPRINT DD   SYSOUT=*
//SYSLIB  DD   DISP=SHR,DSN=PP.LECH.COBOL                    <===CHANGE
//         DD   DSN=SYS1.&SYSMINL..ACEESRC1,DISP=SHR         <===CHANGE
//SYSIN    DD   DSN=PP.LECH.COBOL(LECHIVPC),DISP=SHR         <===CHANGE
//*
//*
//* LINKEDIT
//*
//*
//* STANDARD LINKEDIT PROC
//*
//LINK     EXEC PGM=HEWL,COND=(4,LT),
// PARM=('XREF,LIST,MAP',
// 'AMODE=31,RMODE=ANY,RENT,REUS')
//SYSUT1   DD   UNIT=VIO,SPACE=(1024,(100,30))
//SYSPRINT DD   SYSOUT=*
//SYSLMOD  DD   DSN=&&LOADLIB(LECHIVPC),DISP=(,PASS),
//            SPACE=(9991,(9991,1,1)),BLKSIZE=32760,RECFM=U
//SYSLIB   DD UNIT=VIO,SPACE=(1,(1,1,1)),BLKSIZE=32760,RECFM=U
//         DD   DSN=SYS1.&SYSMINL..SCEELKED,DISP=SHR         <===CHANGE
//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)
//         DD   *
//*
//* RUN IVP
//*
//RUNIVP   EXEC PGM=LECHIVPC
//STEPLIB  DD   DSN=&&LOADLIB,DISP=SHR
//         DD   DSN=JLP.TEST.LOADLIB,DISP=SHR                <===CHANGE
./ ADD NAME=LECHIVP2 0106-02011-05108-0945-00071-00047-00000-TSO057
//TSO057X JOB (T951V57),'LECHIVPA',                                     JOB04952
//           CLASS=A,MSGCLASS=T,REGION=300M,
//           NOTIFY=TSO057
// INCLUDE MEMBER=SYSLEV
//*
//*
//******************************************************************
//*                                                                *
//*  THIS JOB WILL ASSEMBLE AND LINK LECHIVPA, AND RUN IT          *
//*                                                                *
//******************************************************************
//*
//******************************************************************
//* HISTORY                                                        *
//******************************************************************
//*                                                                *
//* 12 JAN 2002 1.0  WRITTEN                                  AWR  *
//*                                                                *
//******************************************************************
//*
//*      TO RUN THIS JOB
//*      ---------------
//*
//*  1) CHANGE THE JOBCARD
//*
//*
//*  2) CHANGE THE NAMES OF:
//*
//*        PP.LECH.COBOL - TO THE LECHCLL COBOL LIBRARY
//*
//*        JLP.TEST.LOADLIB  - TO THE LOAD LIBRARY WHERE YOU WANT
//*                            LECHCLL TO BE STORED
//*
//*
//*
//*
//ASM      EXEC PGM=ASMA90,COND=(4,LT),
// PARM='NORLD,XREF(SHORT),DECK,NOOBJECT,LIST,TERM,'
//SYSTERM  DD   SYSOUT=*
//SYSPRINT DD   SYSOUT=*
//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1700,(600,600))
//SYSLIN   DD   DUMMY
//SYSPUNCH DD   DSN=&&OBJ,DISP=(NEW,PASS),
//         SPACE=(80,(1500,750)),UNIT=SYSALLDA,BLKSIZE=3120
//SYSLIB   DD   DISP=SHR,DSN=PP.LECH.COBOL      <===CHANGE
//         DD   DSN=SYS1.&SYSMINL..ACEESRC1,DISP=SHR      <===CHANGE
//         DD   DSN=SYS1.MACLIB,DISP=SHR                  <===CHANGE
//SYSIN    DD   DSN=PP.LECH.COBOL(LECHIVPA),DISP=SHR      <===CHANGE
//*
//* LINKEDIT
//*
//LINK     EXEC PGM=HEWL,COND=(4,LT),
// PARM=('XREF,LIST,MAP',
// 'AMODE=31,RMODE=24,NORENT,NOREUS')
//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1024,(100,30))
//SYSPRINT DD   SYSOUT=*
//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)
//         DD   *
//SYSLIB   DD   DSN=SYS1.&SYSMINL..SCEELKED,DISP=SHR      <===CHANGE
//SYSLMOD  DD   DSN=&&LOADLIB(LECHIVPA),DISP=(,PASS),
//            SPACE=(9991,(9991,1,1)),BLKSIZE=32760,RECFM=U
//*
//*
//*
//*
//* RUN IVP
//*
//RUNIVP   EXEC PGM=LECHIVPA
//CEEDUMP  DD   SYSOUT=*
//STEPLIB  DD   DSN=&&LOADLIB,DISP=SHR
//         DD   DSN=JLP.TEST.LOADLIB,DISP=SHR                <===CHANGE
./ ADD NAME=LECHIVP3 0106-02011-09166-1658-00112-00067-00000-TSO057
//TSO057X JOB (T951V57),'LECHIVPE',                                     JOB07358
//           CLASS=A,MSGCLASS=T,REGION=300M,
//           NOTIFY=TSO057,SCHENV=SYSAFF
//*
// INCLUDE MEMBER=SYSLEV
//*
//*
//******************************************************************
//*                                                                *
//*  THIS JOB WILL COMPILE AND LINK LECHIVPE, AND RUN IT           *
//*                                                                *
//******************************************************************
//*
//******************************************************************
//* HISTORY                                                        *
//******************************************************************
//*                                                                *
//* 12 JAN 2002 1.0  WRITTEN                                  AWR  *
//*                                                                *
//******************************************************************
//*
//*      TO RUN THIS JOB
//*      ---------------
//*
//*  1) CHANGE THE JOBCARD
//*
//*
//*  2) CHANGE THE NAMES OF:
//*
//*        SFT.LECH.COBOL - TO THE LECHCLL COBOL LIBRARY
//*
//*        JLP.TEST.LOADLIB  - TO THE LOAD LIBRARY WHERE YOU WANT
//*                            LECHCLL TO BE STORED
//*
//*        SYS1. LIBRARIES   - AS SUITABLE
//*
//*
//*  STANDARD C COMPILE
//*
//COMPILE  EXEC PGM=CCNDRVR,
// COND=(4,LT),
// PARM='/OPTF(DD:O)'
//O DD *
          AGG SHOW NOSEQ
               MAR(1,172)
               INL(AUTO,REPORT,999,999999)
               EXPMAC RENT LO SO
               NOSEARCH
               LIS SS ARCH(7)
//STEPLIB  DD  DSNAME=SYS1.SYSMINL.SCCNCMP,DISP=SHR
//SYSMSGS  DD  DUMMY,DSNAME=SYS1.&SYSMINL..SCEEMSGP(EDCMSGE),DISP=SHR
//SYSLIN   DD  DSNAME=&&OBJ,UNIT=SYSALLDA,
//             DISP=(NEW,PASS),SPACE=(TRK,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),LRECL=80,RECFM=FB
//SYSUT4   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),LRECL=80,RECFM=FB
//SYSUT5   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),LRECL=3200,RECFM=FB
//SYSUT6   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),LRECL=3200,RECFM=FB
//SYSUT7   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),LRECL=3200,RECFM=FB
//SYSUT8   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),LRECL=3200,RECFM=FB
//SYSUT9   DD  UNIT=SYSALLDA,SPACE=(32000,(90,900)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD  UNIT=SYSALLDA,SPACE=(32000,(90,930)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//*
//USERLIB  DD  DISP=SHR,DSN=PP.LECH.COBOL
//SYSLIB   DD  DSN=SYS1.&SYSMINL..SCEEH.H,DISP=SHR         <===CHANGE
//         DD  DSN=SYS1.&SYSMINL..SCEESAMP,DISP=SHR        <===CHANGE
//         DD  DSN=SYS1.&SYSMINL..SCEEH.SYS.H,DISP=SHR     <===CHANGE
//SYSIN    DD  DSN=PP.LECH.COBOL(LECHIVPE),DISP=SHR        <===CHANGE
//*
//* PRE-LINKEDIT STEP:
//*
//PLKED   EXEC PGM=EDCPRLK,COND=(4,LT),REGION=7M,
// PARM=''
//SYSMSGS  DD  DSNAME=SYS1.&SYSMINL..SCEEMSGP(EDCPMSGE),     <===CHANGE
//             DISP=SHR
//SYSMOD   DD  DSNAME=&&OBJ,UNIT=SYSALLDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DSN=&&OBJ,DISP=(SHR,DELETE)
//*
//*
//*
//* STANDARD LINKEDIT PROC
//*
//LINK     EXEC PGM=HEWL,COND=(4,LT),
// PARM=('XREF,LIST,MAP',
// 'AMODE=31,RMODE=ANY,RENT,REUS')
//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1024,(100,30))
//SYSPRINT DD   SYSOUT=*
//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)
//         DD   *
//SYSLIB DD UNIT=SYSALLDA,SPACE=(1,(1,1,1)),BLKSIZE=32760,RECFM=U
//         DD   DSN=SYS1.&SYSMINL..SCEELKED,DISP=SHR         <===CHANGE
//SYSLMOD  DD   DSN=&&LOADLIB(LECHIVPE),DISP=(,PASS),
//            SPACE=(9991,(9991,1,1)),BLKSIZE=32760,RECFM=U
//*
//*
//*
//*
//* RUN IVP
//*
//RUNIVP   EXEC PGM=LECHIVPE
//STEPLIB  DD   DSN=&&LOADLIB,DISP=SHR
//         DD   DSN=JLP.TEST.LOADLIB,DISP=SHR                <===CHANGE
./ ADD NAME=LECHMOVE 0105-05097-05097-1429-00273-00266-00273-TSO057
000100******************************************************************
000200*                                                                *
000300* LECHMOVE is a sample program which is may be used to move      *
000400* data which may be in invalid or inaccessable locations         *
000410* to locations which may themselves be invalid or protected.     *
000420*                                                                *
000430*                                                                *
000440* It has its own error handler   which sets the resume cursor    *
000450* 'one program up' if it is entered.  The effect of this is      *
000460* to abandon all work in this module and go back to the calling  *
000470* program.                                                       *
000480*                                                                *
000490******************************************************************
000500 IDENTIFICATION DIVISION.
000600 PROGRAM-ID. 'LECHMOVE'.
000700 DATA DIVISION.
000800 WORKING-STORAGE SECTION.
000900
001000 01  ERROR-WRKCNT            PIC 9(9) COMP VALUE 0.
001100
001200 01  LECHLX-SETUP-ERROR           PIC X(40) VALUE
001300                        'I REGISTRATION OF LECHLX FAILED$'.
001400 01  LECHLX-UNREG-ERROR           PIC X(40) VALUE
001500                        'I UNREGISTRATION OF LECHLX FAILED$'.
001600 01  LECHLX-ROUTINE-POINTER     PROCEDURE-POINTER.
001700 01  LECHLX-TOKEN               PIC 9(9) COMP VALUE 0.
001800
001900 01  FEEDBACK.
002000     04  FEEDBACK-CONDITION-TOKEN-VALUE.
002100     COPY  CEEIGZCT.
002200         07  FEEDBACK-CASE-1-CONDITION-ID.
002300             10  FEEDBACK-SEVERITY        PIC S9(4) COMP.
002400             10  FEEDBACK-MSG-NO          PIC S9(4) COMP.
002500         07  FEEDBACK-CASE-2-CONDITION-ID
002600                   REDEFINES FEEDBACK-CASE-1-CONDITION-ID.
002700             10  FEEDBACK-CLASS-CODE      PIC S9(4) COMP.
002800             10  FEEDBACK-CAUSE-CODE      PIC S9(4) COMP.
002900         07  FEEDBACK-CASE-SEV-CTL    PIC X.
003000         07  FEEDBACK-FACILITY-ID     PIC XXX.
003100     04  FEEDBACK-I-S-INFO        PIC 9(9) COMP.
003200
003300 01  CEEMOUT-MSG.
003400     04  CEEMOUT-MSG-LEN               PIC S9(4) COMP VALUE 80.
003500     04  CEEMOUT-MSG-TEXT              PIC X(80).
003600
003700 01  CEEMOUT-DEST                  PIC S9(9) COMP VALUE 2.
003800
003900 01  EDITNUM                       PIC ZZZZZZZZ9.
004000
004100
004200 LINKAGE SECTION.
004300
004400 01  FROM-FIELD              PIC X(9999999).
004500 01  TO-FIELD                PIC X(9999999).
004600 01  MOVE-LENGTH             PIC 9(9) COMP.
004700 01  MOVE-REPLY              PIC X.
004800
004900 PROCEDURE DIVISION USING
005000     FROM-FIELD TO-FIELD MOVE-LENGTH MOVE-REPLY.
005100
005200     SET LECHLX-ROUTINE-POINTER TO ENTRY 'LECHLX'
005300
005400     CALL 'CEEHDLR' USING LECHLX-ROUTINE-POINTER LECHLX-TOKEN
005500                          FEEDBACK
005600
005700     IF FEEDBACK-SEVERITY NOT = 0
005800         ADD 1 TO ERROR-WRKCNT
005900         IF ERROR-WRKCNT < 10
006000             STRING '         LECHMOVE ERROR CALLING CEEHDLR'
006100             DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
006200             PERFORM SEND-MSG-TEXT
006300             PERFORM SEND-MSG-FEEDBACK
006400         END-IF
006500         MOVE 'N' TO MOVE-REPLY
006600         GOBACK
006700     END-IF
006800
006900     MOVE 'N' TO MOVE-REPLY
006910     IF MOVE-LENGTH = 0 GOBACK END-IF
006920
006930     MOVE FROM-FIELD(1:MOVE-LENGTH) TO TO-FIELD(1:MOVE-LENGTH)
006940     MOVE 'V' TO MOVE-REPLY
006950     CALL 'CEEHDLU' USING LECHLX-ROUTINE-POINTER
006960                          FEEDBACK
006970
006980     IF FEEDBACK-SEVERITY NOT = 0
006990         ADD 1 TO ERROR-WRKCNT
007000         IF ERROR-WRKCNT < 10
007100             STRING '         LECHMOVE ERROR CALLING CEEHDLU'
007200             DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
007300             PERFORM SEND-MSG-TEXT
007400             PERFORM SEND-MSG-FEEDBACK
007500         END-IF
007600         GOBACK
007700     END-IF
007800
007900     GOBACK
008000     .
008100
008200 SEND-MSG-FEEDBACK.
008300
008400     PERFORM SEND-MSG-TEXT
008500
008600     MOVE FEEDBACK-SEVERITY TO EDITNUM
008700     STRING '                  SEVERITY = ' EDITNUM
008800     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
008900     PERFORM SEND-MSG-TEXT
009000     MOVE FEEDBACK-MSG-NO TO EDITNUM
009100     STRING '                  MSG-NO   = ' EDITNUM
009200     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
009300     PERFORM SEND-MSG-TEXT
009400     MOVE FEEDBACK-CASE-SEV-CTL TO EDITNUM
009500     STRING '                  SEV-CTL  = ' EDITNUM
009600     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
009700     PERFORM SEND-MSG-TEXT
009800     MOVE FEEDBACK-FACILITY-ID TO EDITNUM
009900     STRING '                  FACILITY = ' EDITNUM
010000     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
010100     PERFORM SEND-MSG-TEXT
010200     MOVE FEEDBACK-I-S-INFO TO EDITNUM
010300     STRING '                  I-S-INFO = ' EDITNUM
010400     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
010500     PERFORM SEND-MSG-TEXT
010600     .
010700
010800 SEND-MSG-TEXT.
010900
011000
011100     CALL 'CEEMOUT' USING CEEMOUT-MSG CEEMOUT-DEST FEEDBACK
011200     MOVE ' ' TO CEEMOUT-MSG-TEXT
011300     .
011400
011500 END PROGRAM 'LECHMOVE'.
011600
011700
011800
011900******************************************************************
012000*                                                                *
012100* LECHLX IS THE ERROR HANDLER FOR LECHMOVE                       *
012200*                                                                *
012300* IT SETS THE RESUME CURSOR ONE PROGRAM UP                       *
012400*                                                                *
012500******************************************************************
012600 IDENTIFICATION DIVISION.
012700 PROGRAM-ID. 'LECHLX'.
012800 DATA DIVISION.
012900 WORKING-STORAGE SECTION.
013000
013100 01  ERROR-WRKCNT            PIC 9(9) COMP VALUE 0.
013200
013300 01  CURSOR-MOVE             PIC 9(9) COMP.
013400
013500 01  FEEDBACK.
013600     04  FEEDBACK-CONDITION-TOKEN-VALUE.
013700     COPY  CEEIGZCT.
013800         07  FEEDBACK-CASE-1-CONDITION-ID.
013900             10  FEEDBACK-SEVERITY        PIC S9(4) COMP.
014000             10  FEEDBACK-MSG-NO          PIC S9(4) COMP.
014100         07  FEEDBACK-CASE-2-CONDITION-ID
014200                   REDEFINES FEEDBACK-CASE-1-CONDITION-ID.
014300             10  FEEDBACK-CLASS-CODE      PIC S9(4) COMP.
014400             10  FEEDBACK-CAUSE-CODE      PIC S9(4) COMP.
014500         07  FEEDBACK-CASE-SEV-CTL    PIC X.
014600         07  FEEDBACK-FACILITY-ID     PIC XXX.
014700     04  FEEDBACK-I-S-INFO        PIC 9(9) COMP.
014800
014900 01  CEEMOUT-MSG.
015000     04  CEEMOUT-MSG-LEN               PIC S9(4) COMP VALUE 80.
015100     04  CEEMOUT-MSG-TEXT              PIC X(80).
015200
015300 01  CEEMOUT-DEST                  PIC S9(9) COMP VALUE 2.
015400
015500 01  EDITNUM                       PIC ZZZZZZZZ9.
015600
015700 LINKAGE SECTION.
015800
015900
016000 01  TOKEN                   PIC 9(9) COMP.
016100
016200 01  RESULT                  PIC 9(9) COMP.
016300     88 RESUME                   VALUE 10.
016400
016500 01  CURCOND.
016600
016700     04  CURCOND-CONDITION-TOKEN-VALUE.
016800     COPY  CEEIGZCT.
016900         07  CURCOND-CASE-1-CONDITION-ID.
017000             10  CURCOND-SEVERITY        PIC S9(4) COMP.
017100             10  CURCOND-MSG-NO          PIC S9(4) COMP.
017200         07  CURCOND-CASE-2-CONDITION-ID
017300                   REDEFINES CURCOND-CASE-1-CONDITION-ID.
017400             10  CURCOND-CLASS-CODE      PIC S9(4) COMP.
017500             10  CURCOND-CAUSE-CODE      PIC S9(4) COMP.
017600         07  CURCOND-CASE-SEV-CTL    PIC X.
017700         07  CURCOND-FACILITY-ID     PIC XXX.
017800     04  CURCOND-I-S-INFO        PIC 9(9) COMP.
017900
018000 01  NEWCOND.
018100
018200     04  NEWCOND-CONDITION-TOKEN-VALUE.
018300     COPY  CEEIGZCT.
018400         07  NEWCOND-CASE-1-CONDITION-ID.
018500             10  NEWCOND-SEVERITY        PIC S9(4) COMP.
018600             10  NEWCOND-MSG-NO          PIC S9(4) COMP.
018700         07  NEWCOND-CASE-2-CONDITION-ID
018800                   REDEFINES NEWCOND-CASE-1-CONDITION-ID.
018900             10  NEWCOND-CLASS-CODE      PIC S9(4) COMP.
019000             10  NEWCOND-CAUSE-CODE      PIC S9(4) COMP.
019100         07  NEWCOND-CASE-SEV-CTL    PIC X.
019200         07  NEWCOND-FACILITY-ID     PIC XXX.
019300     04  NEWCOND-I-S-INFO        PIC 9(9) COMP.
019400
019500
019600 PROCEDURE DIVISION USING
019700     CURCOND, TOKEN, RESULT, NEWCOND.
019800
019900*    DISPLAY 'LECHLX ENTERED'
020000     MOVE 1 TO CURSOR-MOVE
020100     CALL 'CEEMRCR' USING CURSOR-MOVE FEEDBACK
020200     IF FEEDBACK-SEVERITY NOT = 0
020300         STRING '         LECHLX ERROR CALLING CEEMRCR'
020400         DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
020500         PERFORM SEND-MSG-TEXT
020600         PERFORM SEND-MSG-FEEDBACK
020700         ADD 1 TO ERROR-WRKCNT
020800         IF ERROR-WRKCNT > 1000
020900             CALL 'CONMESSG' USING BY CONTENT
021000             'C LECH SERIOUS INTERNAL ERROR IN LECHLX$'
021100         END-IF
021200     END-IF
021300
021400     SET RESUME TO TRUE
021500*    DISPLAY 'LECHMOVE RET'
021600     GOBACK
021700     .
021800
021900 SEND-MSG-FEEDBACK.
022000
022100     PERFORM SEND-MSG-TEXT
022200
022300     MOVE FEEDBACK-SEVERITY TO EDITNUM
022400     STRING '                  Severity = ' EDITNUM
022500     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
022600     PERFORM SEND-MSG-TEXT
022700     MOVE FEEDBACK-MSG-NO TO EDITNUM
022800     STRING '                  Msg-No   = ' EDITNUM
022900     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
023000     PERFORM SEND-MSG-TEXT
023100     MOVE FEEDBACK-CASE-SEV-CTL TO EDITNUM
023200     STRING '                  Sev-Ctl  = ' EDITNUM
023300     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
023400     PERFORM SEND-MSG-TEXT
023500     MOVE FEEDBACK-FACILITY-ID TO EDITNUM
023600     STRING '                  Facility = ' EDITNUM
023700     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
023800     PERFORM SEND-MSG-TEXT
023900     MOVE FEEDBACK-I-S-INFO TO EDITNUM
024000     STRING '                  I-S-Info = ' EDITNUM
024100     DELIMITED SIZE INTO CEEMOUT-MSG-TEXT
024200     PERFORM SEND-MSG-TEXT
024300     .
024400
024500
024600 SEND-MSG-TEXT.
024700
024800
024900     CALL 'CEEMOUT' USING CEEMOUT-MSG CEEMOUT-DEST FEEDBACK
025000     MOVE ' ' TO CEEMOUT-MSG-TEXT
025100     .
025200
025300
025400 END PROGRAM 'LECHLX'.
025500
./ ADD NAME=LECHNL   0103-05105-05105-1518-00297-00294-00004-TSO057
***********************************************************************
*                                                                     *
*        LECHNL IS A NON-LE ESTAE ROUTINE                             *
*                                                                     *
*        TO USE IT JUST CODE                                          *
*                         CALL LECHNL                                 *
*                                                                     *
*        AT THE START OF YOUR NON-LE PROGRAM                          *
*                                                                     *
*        IT NEEDS THE INSTASM ROUTINES AVAILABLE AT                   *
*    http://home.clara.net/andywrobertson/mvsindex.html               *
*                                                                     *
***********************************************************************
LECHNL  INSTSS  VER=20
NOTFST   NOP   LECHNLZ
         OI    NOTFST+1,X'F0'           FIRST TIME THRU ONLY
         IPM   R3                       SAVE PROGRAM MASK
         ESPIE SET,LECHNL4,((1,15))     POINT TO LECHNL4, ALL INTS
         SPM   R3
LECHNLZ  DS    0H
        INSTRS
         LTORG
        INSTWORK  START
        INSTWORK  END

***********************************************************************
*                                                                     *
*        LECHNL4 IS THE ESPIE CSECT.  IT IS ENTERED DIRECT FROM       *
*        THE CALLING PROGRAM WHEN THE INTERRUPT OCCURRS.              *
*                                                                     *
*        ON ENTRY THE REGISTERS HAVE BEEN SET TO:                     *
*                                                                     *
*        R1    ->  EPIE                                               *
*        R2-13     AS IN PROGRAM WHERE INTERRUPT HAPPENED             *
*        R14   ->  RETURN ADDRESS TO SYSTEM                           *
*        R15   ->  LECHNL4                                            *
*                                                                     *
*        THE REGISTERS AS THEY WERE WHEN THE INTERRUPT HAPPENED       *
*        ARE SAVED IN A SAVE AREA IN THE EPIE (AT EPIEGPR)            *
*                                                                     *
***********************************************************************

LECHNL4  CSECT
         PUSH USING
         USING *,R15
         LR    R12,R15
         DROP R15
         USING LECHNL4,R12
         LA    R13,SAVEAREA

         ST    R14,RET@

         LR    R9,R1
         USING EPIE,R9

*        SET AMODE IN THIS CSECT TO 31

         SLR   R1,R1
         LA    R1,SETAMODE
         O     R1,=A(X'80000000')
         BSM   0,R1
SETAMODE DS    0H

*        GET TRUE INSTRUCTION ADDRESS

         L     R1,EPIENXT1
         N     R1,=A(X'7FFFFFFF')
         TM    EPIENXT1,EPIEMOD1
         BO    AMODE_31
         N     R1,=A(X'00FFFFFF')
AMODE_31 DS    0H
         ST    R1,TRUE_INT

         L     R1,TOT_INT_NUMBER
         LA    R1,1(R1)
         ST    R1,TOT_INT_NUMBER

         BAL   R6,A000_ANALYSE

*        RETURN TO INTERRUPTED PROGRAM
*
*
*        IF ILC IS 0, THEN THE RETURN MAY BE STRAIGHT BACK TO
*        THE FAILING INSTRUCTION: THIS WILL LEAD TO AN ENDLESS LOOP.
*        TO AVOID THIS, WE TEST: IF THE INSTRUCTION LENGTH
*        EPIEINT WAS 0, WE GET THE INSTRUCTION LENGTH
*        (BY ACTUALLY LOOKING AT THE
*        INSTRUCTION IN THE PROGRAM) AND ADD THIS TO THE EPIEPSW
*

         CLI   EPIEILC1,0    IF INSTRUCTION LENGTH WAS 0
         BNE   DONT_ADJ_PSW
         LA    R2,2                     R2 HOLDS LEN INST
*
*        WE CAN ONLY LOOK AT INSTR IF INTERRUPT IS OF TYPE THAT
*        CAN NOT POSSIBLY BE DUE TO INSTR NOT ACCESSIBLE
*
         CLI   EPIEICD1,1 OPERATION
         BE    LOOKAT_INST
         CLI   EPIEICD1,2 PRIVILEDGED
         BE    LOOKAT_INST
         CLI   EPIEICD1,3 EXECUTE
         BE    LOOKAT_INST
         CLI   EPIEICD1,6 SPECIFICATION
         BE    LOOKAT_INST
         CLI   EPIEICD1,7 DATA
         BE    LOOKAT_INST
         CLI   EPIEICD1,8 FIXED POINT OVERFLOW
         BE    LOOKAT_INST
         CLI   EPIEICD1,9  FIXED POINT DIVIDE
         BE    LOOKAT_INST
         CLI   EPIEICD1,10 DEC OVERFLOW
         BE    LOOKAT_INST
         CLI   EPIEICD1,11 DEC DIVIDE
         BE    LOOKAT_INST
         CLI   EPIEICD1,12 EXP OVERFLOW
         BE    LOOKAT_INST
         CLI   EPIEICD1,13 EXP UNDERFLOW
         BE    LOOKAT_INST
         CLI   EPIEICD1,14 SIGNIFICANCE
         BE    LOOKAT_INST
         CLI   EPIEICD1,15 FLOATING POINT DIVIDE
         BE    LOOKAT_INST
         B     ADJ_PSW
LOOKAT_INST DS   0H
         L     R3,TRUE_INT
         CLI   0(R3),X'40'
         BL    ADJ_PSW
         LA    R2,2(R2)
         CLI   0(R3),X'C0'
         BL    ADJ_PSW
         LA    R2,2(R2)
ADJ_PSW  EQU    *
         L     R8,EPIEPSW+4
         ALR   R8,R2
         ST    R8,EPIEPSW+4
DONT_ADJ_PSW  EQU   *
RETURN_TO_SYSTEM DS  0H
         L     R14,RET@
         BSM   0,R14        RETURN TO SYSTEM



A000_ANALYSE DS  0H
         L     R1,TOT_INT_NUMBER
         SLR   R0,R0
         D     R0,=A(10000)
         C     R0,=A(0)
         BNE   A001_NOT10000
         MVC   MSG,=CL100' LECHNL - ANOTHER 10,000 INTERRUPTS!!!'
         CALL  INSTWTOR,(MSG),VL
A001_NOT10000  DS    0H

*        CHECK TO SEE IF LOW CORE

         CLC   TRUE_INT,=A(4096)
         BH    A010_NOTLOW
         MVC   MSG,=CL100' LECHNL - LOW CORE, JOB ABENDED '
         CALL   INSTWTOR,(MSG),VL
         ABEND  450,DUMP

A010_NOTLOW EQU *

*        CHECK TO SEE IF DUPLICATE DUMP

         L     R7,TRUE_INT
         LA    R5,INTTAB
         USING  INTDS,R5
         LA    R1,0
         ST    R1,DIF_INT_NUMBER
A020_INTLOOP1 DS 0H
         L     R1,DIF_INT_NUMBER
         LA    R1,1(R1)
         ST    R1,DIF_INT_NUMBER
         CLC   =F'-1',INTDS_TRUE_INT
         BE    TOO_MANY_INTS
         CLC   =F'0',INTDS_TRUE_INT
         BNE   A030_NOTNEW
         ST    R7,INTDS_TRUE_INT
         MVC   INTDS_OCCURRED,=A(1)
         B     A030_INTLOOPZ
A030_NOTNEW DS 0H
         C     R7,INTDS_TRUE_INT
         BNE   A030_NOTTHIS
         L     R1,INTDS_OCCURRED
         LA    R1,1(R1)
         ST    R1,INTDS_OCCURRED
         B     A030_INTLOOPZ
A030_NOTTHIS DS 0H
         LA    R5,INTDSZ-INTDS(R5)
         B     A020_INTLOOP1
A030_INTLOOPZ DS 0H
         CLC   =F'1',INTDS_OCCURRED
         BNE   A040_NOTFIRST
         BAL   R10,B000_FIRST_TIME_THIS_DUMP
A040_NOTFIRST DS 0H

         BR    R6




INTTAB   DC     30A(0,0)  TRUE ADDR INT, NO OF INTS THERE
         DC     F'-1'
         DC     F'-1'
         DC     F'-1'




TOO_MANY_INTS  DS   0H
         MVC    MSG,=CL100' LECHNL TOO MANY INTERRUPTS - JOB ABENDED '
         CALL   INSTWTOR,(MSG),VL
         ABEND 450,DUMP





B000_FIRST_TIME_THIS_DUMP DS  0H
*        WTO   'B000'
*        WTO   'C000'
         MVC   ERROR_TYPE,=C'????????????????????'
         SLR   R1,R1
         IC    R1,EPIEICD1
         BCTR  R1,0                    DECREM
         MH    R1,=Y(L'ERRORS_TAB)     MULTIPLY BY PIC TECXT LEN
         L     R2,=A(ERRORS_TAB)
         LA    R1,0(R2,R1)
         C     R1,=A(ERRORS_TAB)
         BL    B100_UNKNOWN_ERROR
         C     R1,=A(ERRORS_TABZ)
         BNL   B100_UNKNOWN_ERROR
         MVC   ERROR_TYPE,0(R1)        PRINT PROG INT CODE TEXT
B100_UNKNOWN_ERROR DS 0H
         L    R2,TRUE_INT
         SL   R2,MODULE_INT_START
         MVI  MSG,C' '
         MVC  MSG+1(L'MSG-1),MSG
         MVC  MSG(22),=CL22' LECHNL INTERRUPT AT '
         CALL INSTCNVX,(TRUE_INT,X8,A4),VL
         MVC  MSG+23(8),X8
         MVC  MSG+32(3),=C' - '
         MVC  MSG+36(L'ERROR_TYPE),ERROR_TYPE
         CALL  INSTWTOR,(MSG),VL
         BR    R10

MODULE_INT DS  CL8
X8         DS  CL8
A4         DC  A(4)
MODULE_INT_START DS A




ERRORS_TAB DC  CL20'OPERATION'
         DC    CL20'PRIVILEGED OPERATION'
         DC    CL20'EXECUTE'
         DC    CL20'PROTECTION'
         DC    CL20'ADDRESSING'
         DC    CL20'SPECIFICATION'
         DC    CL20'DECIMAL DATA'
         DC    CL20'FIXED POINT OVERFLOW'
         DC    CL20'FIXED POINT DIVIDE'
         DC    CL20'DECIMAL OVERFLOW'
         DC    CL20'DECIMAL DIVIDE'
         DC    CL20'EXPONENT OVERFLOW'
         DC    CL20'EXPONENT UNDERFLOW'
         DC    CL20'SIGNIFICANCE'
         DC    CL20'FLOATNG POINT DIVIDE'
ERRORS_TABZ DS 0C
ERROR_TYPE DC  CL20' '




DIF_INT_NUMBER DC A(0)
TOT_INT_NUMBER DC A(0)
MSG      DC    CL100' '
SAVEAREA DS    18F
TCBADDR  DS    F
RET@     DS    F
TRUE_INT DS    F
ECBWAIT  DC    A(0)

*
         LTORG
         IHAEPIE
INTDS    DSECT
INTDS_TRUE_INT DS A
INTDS_OCCURRED DS A
INTDSZ   DS  0C

         END

         COPY INSTCNVX
        COPY INSTWTOR
